---
title:   Types of Process Injection
classes: wide
header:
  teaser: /img/process.PNG
ribbon: red
categories:
  - Malware-Analysis
toc: true
---

# Process Injection

Process injection is a common evasion tactic that used by malware authors in order to hide malicious code into legitimate processes and execute it on a system, also allow malware to gain access to other processes.

Attackers can employ a number of techniques in order to accomplish process injection, including spawning new processes in a suspended state, allocating memory within them, and then writing malicious code into this created memory space (process hollowing), or injecting a thread into an existing process.

Some of these techniques can be inferred by the presence of certain API calls within the binary.
The API calls are listed here:

* VirtualAllocEx
* WriteProcessMemory
* CreateRemoteThread
* NtCreateThreadEx
* QueueThreadAPC

Any combination of these APIs, in combination with APIs such as CreateToolHelp32Snapshot, should be viewed as a suspect. It's likely the sample is enumerating running processes in order to iterate through and find the process they would like to utilize as a target for process injection.

<!-- more -->

# Types of Process Injection 

 Although there are myriad different ways with technical differences involved in calling the APIs and injecting into processes. Only fundamental Process Injection techniques are discussed here.

# Classic DLL injection

DLL-Injection is the most common technique that used by malware to inject malicious code into other processes to evade detection, and every processes need to load dynamic link Libraries to work, So it became easy to load malicious code in legitimate processes. 

In classic DLL injection, the malicious process will often utilize CreateToolHelp32Snapshot in order to iterate through processes until it locates the process it would like to target. Once located, the malicious process will utilize VirtualAlloc and WriteProcessMemory to write the path for a malicious DLL into the virtual address space of the target process.

<p align="center">
    <img width="60%" src="https://haxer007.github.io/img/dll-injection.gif" />
 </p>


Once the DLL's path is written into the virtual memory space of the target process, the malicious process will utilize CreateRemoteThread in order to force the process to load the malicious library.
    The malware first needs to target a process for injection (e.g. svchost.exe). This is usually done by searching through processes by calling a trio of Application Program Interfaces (APIs): CreateToolhelp32Snapshot, Process32First, and Process32Next. CreateToolhelp32Snapshot is an API used for enumerating heap or module states of a specified process or all processes, and it returns a snapshot. Process32First retrieves information about the first process in the snapshot, and then Process32Next is used in a loop to iterate through them. After finding the target process, the malware gets the handle of the target process by calling OpenProcess.
        
  <p align = "center">      
  <img width="50%" src="https://haxer007.github.io/img/dll.png" />
   </p>     
   <p align = "center">      
  Figure 1:A typical DLL Injection<br>
  </p>      
        
   As shown in Figure 1, the malware calls VirtualAllocEx to have a space to write the path to its DLL. The malware then calls WriteProcessMemory to write the path in the allocated memory. Finally, to have the code executed in another process, the malware calls APIs such as CreateRemoteThread. However, the general idea is to pass the address of LoadLibrary to one of these APIs so that a remote process has to execute the DLL on behalf of the malware.



# PE Injection
This technique is highly similar to classic DLL injection. Instead of injecting the path to the DLL into the virtual memory of the process, the malware will create address space utilizing VirtualAlloc, then write a PE directly into the memory address space using WriteProcessMemory, and ensure code execution by utilizing CreateRemoteThread or similar undocumented APIs such as NTCreateThreadEx.

<p align="center">
  <img src="https://haxer007.github.io/img/pe-injection.gif" />
  
 Figure 2: When analyzing PE injection, it is very common to see loops (usually two “for” loops, one nested in the other), before a call to CreateRemoteThread. This technique is quite popular among crypters 
  
  
</p>
<p align="center">
  <img width="50%" src="https://haxer007.github.io/img/pe.png" />
</p>
   <p align = "center">      
  Figure 2:PE Injection<br>
  </p>      


# Thread Execution Hijacking
In this technique, the malware will suspend an existing thread of a process. 
First, the malware will suspend the thread, utilize VirtualAlloc to clear memory space for the path of the DLL, and inject the path to the DLL and a call to LoadLibrary in order to load the malicious DLL into the existing thread in the process. The malware will then instruct the thread to resume.

<p align="center">
  <img src="https://haxer007.github.io/img/hijack.gif" />
</p>

   Figure 4: In order to hijack the execution of the thread, the malware modifies the EIP register (a register that contains the address of the next instruction) of the targeted thread by calling SetThreadContext. Afterwards, malware resumes the thread to execute the shellcode that it has written to the host process.


<p align="center">
  <img width="50%" src="https://haxer007.github.io/img/hijack.png" />
</p>
 <p align = "center">      
  Figure 3: Thread Execution Hijacking<br>
  </p>      



# Process Hollowing
In Process hollowing the malicious process will spawn a legitimate process in a suspended state and will then unmap the legitimate code from the process utilizing VirtualAlloc. The code within the process will then be replaced with malicious code utilizing WriteProcessMemory, and the process will be resumed.

<p align="center">
  <img src="https://haxer007.github.io/img/process-injection.gif" />
</p> 

The malware first creates a new process to host the malicious code in suspended mode. As shown in Figure 3, this is done by calling CreateProcess and setting the Process Creation Flag to CREATE_SUSPENDED. The primary thread of the new process is created in a suspended state, and does not run until the ResumeThread function is called. Next, the malware needs to swap out the contents of the legitimate file with its malicious payload. This is done by unmapping the memory of the target process by calling either ZwUnmapViewOfSection or NtUnmapViewOfSection. These two APIs basically release all memory pointed to by a section. Now that the memory is unmapped, the loader performs VirtualAllocEx to allocate new memory for the malware, and uses WriteProcessMemory to write each of the malware’s sections to the target process space. The malware calls SetThreadContext to point the entrypoint to a new code section that it has written. At the end, the malware resumes the suspended thread by calling ResumeThread to take the process out of suspended state.


<p align="center">
  <img width="50%" src="https://haxer007.github.io/img/peh.png" />
</p>
<p align = "center">      
  Figure 4: Process Hollowing<br>
</p>  



# References:

* [Malware-Analysis-Techniques By Dylan Barke from PacktPub](https://www.packtpub.com/product/malware-analysis-techniques/9781839212277)
* [Malware Unicorn Workshop](https://malwareunicorn.org/workshops/peinjection.html#3)
* [A technical survey of common and trending process injection techniques](https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)
* [MalwareTech Blog](https://www.malwaretech.com/2013/11/portable-executable-injection-for.html)











 



