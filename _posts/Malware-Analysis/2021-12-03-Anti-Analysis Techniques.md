---
title:   Anti-Analysis Techniques
classes: wide
header:
  teaser: /img/Emotet.png
ribbon: red
categories:
  - Malware-Analysis
toc: true
---

# Introduction
    The anti-analysis technology of malware has always been the focus in the computer security field. 
    Malware nowadays often implement certain self-protection techniques to interrupt static and dynamic analysis. 

    Anti-static analysis uses the method of packers and code obfuscation to disturb disassembly and the identification of process control flow. 
    Anti-dynamic analysis detects system operating environment information to realize the anti-tracking for debugger and virtual machines.

    Various techniques are employed by analysts to analyze a malware like spawning up an isolated VM and then capturing artifacts, running malware in automated sandbox environments, etc. but most malware have become sophisticated now and they check for the environments in which they are operating, and only when they see the free environment they exhibit their full characteristics. Below are some of the anti-analysis techniques that malware employs to protect themselves from being analyzed.

# Debugger Detection

      Debuggers are the most common tools that malware analysts use to dissect malware and reveal its functionality.
      Therefore, malware authors implement various anti-debugging tricks to keep their Command & Control servers (C&Cs) hidden and their configurations, exfiltrated data, and their communication with the malware well protected.

  ## Debug Flags:
      The operating system sets special flags describing process state. These flags reside in process memory. The states of these flags can be verified either by using specific API functions or examining the system tables in memory. They can be used to indicate that the process is being debugged.

      1. Using Win32 API :

          WinAPI provides API functions that check system structures in the process memory for particular flags which can be used to indicate whether a process is being debugged.

          1.1. IsDebuggerPresent()

                The function kernel32!IsDebuggerPresent() determines whether the current process is being debugged by a user-mode debugger. Generally, the function only checks the BeingDebugged flag of the Process Environment Block (PEB).

          1.2. CheckRemoteDebuggerPresent()

                The function kernel32!CheckRemoteDebuggerPresent() checks if a debugger (in a different process on the same machine) is attached to the current process.
                If a debugger is present, the return value will be a nonzero.



      2. Manual Check:

          2.1. PEB!BeingDebugged Flag

                The Process Environment Block (PEB) is a user-mode data structure that can be used by applications (and by extend by malware) to get information such as the list of loaded modules, process startup arguments, heap address, check whether program is being debugged, find image base address of imported DLLs, ...

                BeingDebugged flag can also be checked manually by directly accessing PEB(0x02 offset of Process Environment Block).In this approach flag is examined manually in process memory without using special debug API functions.
                This method is just another way to check BeingDebugged flag of PEB without calling IsDebuggerPresent().

          2.2. NtGlobalFlag

                The NtGlobalFlag field of the Process Environment Block (0x68 offset on 32-Bit and 0xBC on 64-bit Windows) is 0 by default. Attaching a debugger doesnâ€™t change the value of NtGlobalFlag. However, if the process was created by a debugger, the following flags will be set:

                  FLG_HEAP_ENABLE_TAIL_CHECK (0x10)
                  FLG_HEAP_ENABLE_FREE_CHECK (0x20)
                  FLG_HEAP_VALIDATE_PARAMETERS (0x40)
                when a process is not being debugged, the NtGlobalFlag field contains the value 0x0. When the process is being debugged, the field will usually contain the value 0x70 which indicates that the above flags are set.
                The presence of a debugger can be detected by checking a combination of those flags.














 



