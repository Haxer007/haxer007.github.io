---
title:   Anti-Analysis Techniques
classes: wide
header:
  teaser: /img/malware.png
ribbon: red
categories:
  - Malware-Analysis
toc: true
---

# Introduction
   The anti-analysis technology of malware has always been the focus in the computer security field. 
   Malware nowadays often implement certain self-protection techniques to interrupt static and dynamic analysis. 

   Anti-static analysis uses the method of packers and code obfuscation to disturb disassembly and the identification of process control flow. 
   Anti-dynamic analysis detects system operating environment information to realize the anti-tracking for debugger and virtual machines.

   Various techniques are employed by analysts to analyze a malware like spawning up an isolated VM and then capturing artifacts, running malware in automated sandbox environments, etc. but most malware have become sophisticated now and they check for the environments in which they are operating, and only when they see the free environment they exhibit their full characteristics. Below are some of the anti-analysis techniques that malware employs to protect themselves from being analyzed.

# Debugger Detection
   Debuggers are the most common tools that malware analysts use to dissect malware and reveal its functionality.
   Therefore, malware authors implement various anti-debugging tricks to keep their Command & Control servers (C&Cs) hidden and their configurations, exfiltrated data, and their communication with the malware well protected.

# Debug Flags
   The operating system sets special flags describing process state. These flags reside in process memory. The states of these flags can be verified either by using specific API functions or examining the system tables in memory. They can be used to indicate that the process is being debugged.

# Using Win32 API 
   WinAPI provides API functions that check system structures in the process memory for particular flags which can be used to indicate whether a process is being debugged.
   
## IsDebuggerPresent()
   The function kernel32!IsDebuggerPresent() determines whether the current process is being debugged by a user-mode debugger. Generally, the function only checks the BeingDebugged flag of the Process Environment Block (PEB).
   
<p align="center">
<img src="https://user-images.githubusercontent.com/73170547/144640141-784404af-51b9-4560-9e51-7bd658775774.png">
</p>

## CheckRemoteDebuggerPresent()
   The function kernel32!CheckRemoteDebuggerPresent() checks if a debugger (in a different process on the same machine) is attached to the current process. If a debugger is present, the return value will be a nonzero.
   
<p align="center">
<img src="https://user-images.githubusercontent.com/73170547/144641423-caa94d6e-cd5f-4715-a765-069c0949fb27.png">
</p>

Instead of looking for this flag, it checks if the process has a non-zero debug port. Basically, the function will set “pbDebuggerPresent” to TRUE or FALSE depending on the status of the process referenced by “hProcess” pointer. 

# Manual Checks:
   The following approaches are used to validate debugging flags in system structures. They examine the process memory manually without using special debug API functions.

## PEB!BeingDebugged Flag
   The Process Environment Block (PEB) is a user-mode data structure that can be used by applications (and by extend by malware) to get information such as the list of loaded modules, process startup arguments, heap address, check whether program is being debugged, find image base address of imported DLLs, ...
     BeingDebugged flag can also be checked manually by directly accessing PEB(0x02 offset of Process Environment Block).In this approach flag is examined manually in process memory without using special debug API functions.
     
<p align="center">
<img src="https://user-images.githubusercontent.com/73170547/144640347-2b997918-d9d4-4d33-810c-37caf7965e61.png">
</p>
             
This method is just another way to check BeingDebugged flag of PEB without calling IsDebuggerPresent().

## NtGlobalFlag
   The NtGlobalFlag field of the Process Environment Block (0x68 offset on 32-Bit and 0xBC on 64-bit Windows) is 0 by default. Attaching a debugger doesn’t change the value of NtGlobalFlag. However, if the process was created by a debugger, the following flags will be set:
<table align="center" border=1 style="margin: 0px auto;">
<tbody><tr>
<th>Flag
</th>
<th>Value
</th></tr>
<tr>
<td><tt>FLG_HEAP_ENABLE_TAIL_CHECK</tt>
</td>
<td align="center"><tt>0x10</tt>
</td></tr>
<tr>
<td><tt>FLG_HEAP_ENABLE_FREE_CHECK</tt>
</td>
<td align="center"><tt>0x20</tt>
</td></tr>
<tr>
<td><tt>FLG_HEAP_VALIDATE_PARAMETERS</tt>
</td>
<td align="center"><tt>0x40</tt>
</td></tr>
<tr>
<th>Total
</th>
<th><tt>0x70</tt>
</th></tr></tbody></table>

when a process is not being debugged, the NtGlobalFlag field contains the value 0x0. When the process is being debugged, the field will usually contain the value 0x70 which indicates that the above flags are set.
              
<p align="center">
<img src="https://user-images.githubusercontent.com/73170547/144642105-413b265d-f1f6-4fa6-b48e-2bb0c701a35d.png">
</p>
 
The presence of a debugger can be detected by checking a combination of those flags ie.. 0x70.



These were some common techniques used by malware authors to evade automated analysis.

# References

* [Test your Malware Analysis Environment with PaFish](https://github.com/a0rtega/pafish)
* [More Anti Debug Techniques](https://anti-debug.checkpoint.com/techniques/debug-flags.html)
* [PEB-Process-Environment-Block/NtGlobalFlag Wiki](https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag)













 



